<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Smile Detector</title>
    <script src="/face-api.js/dist/face-api.min.js"></script>
    <style>
      /* Center the app horizontally and vertically */
      body {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        height: 100vh;
        margin: 0;
      }

      /* Style the video element */
      #video {
        width: 100%;
        max-width: 640px;
        height: auto;
        border: 1px solid lightgray;
        border-radius: 10px;
        box-shadow: 0 0 10px 4px rgba(0, 0, 0, 0.6);
      }

      #canvas {
        border: 1px solid lightgray;
        border-radius: 10px;
        box-shadow: 0 0 10px 4px rgba(0, 0, 0, 0.6);
      }
    </style>
  </head>
  <body>
    <video id="video" width="640" height="480" autoplay></video>
    <canvas id="canvas"></canvas>

    <script>
      const video = document.getElementById("video");
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      let gameLoopId;

      // Set the canvas size to match the video dimensions
      video.addEventListener("loadedmetadata", function () {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        // Draw a floor on the canvas
        ctx.fillStyle = "gray";
        ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

        // Draw a character on the canvas
        ctx.fillStyle = "yellow";
        ctx.fillRect(canvas.width / 2 - 25, canvas.height - 100, 50, 50);
      });


      let obstacles = [];

function createObstacle() {
  const obstacle = {
    x: canvas.width,
    y: canvas.height - 100,
    width: 50,
    height: 50,
    speed: 5,
  };
  obstacles.push(obstacle);
}

function moveObstacles() {
  for (let i = 0; i < obstacles.length; i++) {
    const obstacle = obstacles[i];
    obstacle.x -= obstacle.speed;

    // Remove obstacles that are off the screen
    if (obstacle.x < -obstacle.width) {
      obstacles.splice(i, 1);
      i--;
    }
  }
}

function drawObstacles() {
  ctx.fillStyle = "red";
  for (let i = 0; i < obstacles.length; i++) {
    const obstacle = obstacles[i];
    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
  }
}

setInterval(function () {
  createObstacle();
}, 2000);


      // Initialize ground movement variables
      let groundX = 0;
      const groundSpeed = 2;

      // Move the ground back and forth
      function moveGround() {
        groundX += groundSpeed;
  if (groundX > canvas.width) {
    groundX = -canvas.width;
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawObstacles();

  ctx.fillStyle = "gray";
  ctx.fillRect(groundX, canvas.height - 50, canvas.width, 50);
  ctx.fillRect(
    groundX + canvas.width,
    canvas.height - 50,
    canvas.width,
    50
  );

  // Draw a character on the canvas
  ctx.fillStyle = "yellow";
  ctx.fillRect(canvas.width / 2 - 25, canvas.height - 100, 50, 50);

  moveObstacles();
      }

      // Request permission to access the user's camera
      navigator.mediaDevices
        .getUserMedia({ video: true })
        .then((stream) => {
          // Set the video element's source to the camera stream
          video.srcObject = stream;
          video.play();
        })
        .catch((error) => {
          console.error("Error accessing camera:", error);
        });

      // Load the face-api.js models
      Promise.all([
        faceapi.nets.tinyFaceDetector.loadFromUri("./face-api.js/weights"),
        faceapi.nets.faceLandmark68Net.loadFromUri("./face-api.js/weights"),
        faceapi.nets.faceExpressionNet.loadFromUri("./face-api.js/weights"),
      ])
        .then(startVideo)
        .catch((error) => {
          console.error("Error loading face-api.js models:", error);
        });

      // Start the video stream and smile detection
      function startVideo() {
        navigator.mediaDevices
          .getUserMedia({ video: true })
          .then((stream) => {
            // Set the video element's source to the camera stream
            video.srcObject = stream;
            video.play();
            // Start smile detection

            gameLoopId = setInterval(detectSmile, 1000 / 1);
            setInterval(drawObstacles, 60);

          })
          .catch((error) => {
            console.error("Error accessing camera:", error);
          });
      }

      let obstacle = {
        x: canvas.width,
        y: canvas.height - 100,
        width: 50,
        height: 50,
        speed: 5,
      };

      // Detect smiles in the video stream
      function detectSmile() {
        // Get the video element's dimensions
        const dimensions = {
          width: video.videoWidth,
          height: video.videoHeight,
        };
        // Detect faces in the video stream
        faceapi
          .detectSingleFace(video, new faceapi.TinyFaceDetectorOptions())
          .withFaceLandmarks()
          .withFaceExpressions()
          .then((result) => {
            // Check if the face is smiling
            if (result && result.expressions.happy > 0.9) {
              // Replace this with the action you want to take when a smile is detected
              console.log("Smile detected!", { result });
              // Make the red square jump
              const jumpHeight = 200;
              const jumpDuration = 500;
              const jumpStartTime = Date.now();
              const jumpEndTime = jumpStartTime + jumpDuration;
              const jumpIntervalId = setInterval(() => {
                const currentTime = Date.now();
                const timeElapsed = currentTime - jumpStartTime;
                const jumpProgress = Math.min(timeElapsed / jumpDuration, 1);
                const jumpDistance =
                  -jumpHeight * Math.sin(jumpProgress * Math.PI);

                const currentY = canvas.height - 100 + jumpDistance;
                // Check if the jump is complete
                if (currentTime >= jumpEndTime) {
                  clearInterval(jumpIntervalId);
                }
                // Update the position of the red square
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "gray";
                ctx.fillRect(0, canvas.height - 50, canvas.width, 50);
                ctx.fillStyle = "green";
                ctx.fillRect(canvas.width / 2 - 25, currentY, 50, 50);
                ctx.fillStyle = "white";
                ctx.font = "bold 20px Arial";
                ctx.fillText(
                  jumpProgress,
                  canvas.width / 2,
                  canvas.height - 25
                );

               
              }, 1000 / 60);
            } else {
              console.log("no detection");
            }
          })
          .catch((error) => {
            console.error("Error detecting faces:", error);
          });
      }

      moveGround();
    </script>
  </body>
</html>
